[["index.html", "R.ComDim (a tutorial) Chapter 1 About", " R.ComDim (a tutorial) Francesc Puig Castellví 2022-10-22 Chapter 1 About This is the documentation of the R.ComDim R-package. "],["introduction.html", "Chapter 2 Introduction 2.1 The ComDim method 2.2 Why should I use ComDim? 2.3 Functions 2.4 Install and load R.ComDim package 2.5 References", " Chapter 2 Introduction 2.1 The ComDim method ComDim (also known as CCSWA) is an unsupervised multi-block method that aims to simultaneously consider multiple data tables to find the latent components that are common to all the tables as well as those that are specific to each data table, along with the contribution of each of the tables to each of these components. ComDim determines a common space describing the dispersion of the samples in all the blocks, each block having a specific weight (salience) associated with each dimension in this common space. Significant differences in the saliences for a given dimension reflect the fact that the dimension contains different amounts of information coming from each block. In addition to the saliences, Local loadings for each analyzed block and two different sets of scores are obtained. The first set corresponds to the Local scores for each analyzed block while the second set is composed of the Global scores, common to all the blocks. 2.2 Why should I use ComDim? To analyze different types of data (ex. multi-omics) and see how they are untangled. To extract the common profiles of related variables (ex. metabolites detected in the same pathway). To deal with unbalanced multi-block datasets (ex. different number of sample replicates in the blocks). However, ComDim can also deal with balanced multi-block datasets. Within the data from the same analytical platform, to evaluate inter-sample variability and batch effects related to the analytical platform. To investigate cross-platform variability, which is useful to detect errors in the sample preparation. 2.3 Functions To successfully extract all the potential of the ComDim method, several functions coded in R are proposed. Some of them are listed below: MultiBlock(): To initialize a MultiBlock object with the first data-block(s). BuildMultiBlock(): To combine several single data-blocks into a MultiBlock object, containing some of them metadata information. ExpandMultiBlock(): To combine several single data-blocks into a MultiBlock object, containing some of them metadata information. NormalizeMultiBlock(): To normalize (some or all) the data-blocks of the MultiBlock object. ProcessMultiBlock(): To apply customized data transformation to (some or all) the data-blocks of the MultiBlock object. ComDim_PCA_MB(): This function applies the ComDim-PCA algorithm on the MultiBlock object resulting from BuildMultiBlock() or ExpandMultiBlock(). For more information on the usage of these functions, please consult the next chapters and the help (?). 2.4 Install and load R.ComDim package if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) library(&quot;devtools&quot;) install_github(&quot;f-puig/R.ComDim&quot;) # Load R.ComDim library(&quot;R.ComDim&quot;) 2.5 References Puig-Castellví, F.; Jouan-Rimbaud Bouveresse, D.; Mazéas, L.; Chapleur, O.; Rutledge, D. N. Rearrangement of incomplete multi-omics datasets combined with ComDim for evaluating replicate cross-platform variability and batch influence. Chemom. Intell. Lab. Syst. 2021, 18 (104422). [https://doi.org/10.1016/j.chemolab.2021.104422] (https://doi.org/10.1016/j.chemolab.2021.104422) Qannari, E. M.; Courcoux, P.; Vigneau, E. Common Components and Specific Weights Analysis Performed on Preference Data. Food Qual. Prefer. 2001, 12 (57), 365368.[https://doi.org/10.1016/S0950-3293(01)00026-X] (https://doi.org/10.1016/S0950-3293(01)00026-X) Mazerolles, G.; Hanafi, M.; Dufour, E.; Bertrand, D.; Qannari, E. M. Common Components and Specific Weights Analysis: A Chemometric Method for Dealing with Complexity of Food Products. Chemom. Intell. Lab. Syst. 2006, 81 (1), 4149. [https://doi.org/10.1016/J.CHEMOLAB.2005.09.004] (https://doi.org/10.1016/J.CHEMOLAB.2005.09.004) Claeys-Bruno, M.; Béal, A.; Rutledge, D. N.; Sergent, M. Use of the Common Components and Specific Weights Analysis to Interpret Supersaturated Designs. Chemom. Intell. Lab. Syst. 2016, 152, 97106. [https://doi.org/10.1016/j.chemolab.2016.01.014] (https://doi.org/10.1016/j.chemolab.2016.01.014) "],["create.html", "Chapter 3 Create a MultiBlock 3.1 Option 1: for small MultiBlocks 3.2 Option 2: for large MultiBlocks 3.3 Option 3: from SummarizedExperiment or MultiAssayExperiment objects. 3.4 Sample correspondence across blocks 3.5 Splitting blocks by the Batch criterion.", " Chapter 3 Create a MultiBlock 3.1 Option 1: for small MultiBlocks In order to use the ComDim algorithm, the data blocks need to be combined into a MultiBlock object. MultiBlock has 5 fields: Samples, Data, Variables, Metadata and Batch. The easiest way to create a MultiBlock is by using the function MultiBlock() as below: b1 = matrix(rnorm(500),10,50) # 10 rows and 50 columns b2 = as.data.frame(matrix(rnorm(800),10,80)) # 10 rows and 80 columns b2[c(2,3,4),c(5,7,8)] &lt;- NA # Making some data missing, just for fun. rownames(b2) &lt;- LETTERS[5:14] # Adding some sample names b3 = MultiBlock(Samples = 1:10, Data = list(s1 = b1, s2 = b2), Variables = list(s1 = 1:ncol(b1), s2 = 1:ncol(b2))) With the code above, a MultiBlock containing 2 blocks was built. As shown, the provided data blocks support the format matrix and data.frame. When building a MultiBlock, only the fields Samples, Data, and Variables are mandatory. b4 = MultiBlock(Samples = 1:10, Data = list(s1 = b1, s2 = b2), Variables = list(s1 = 1:ncol(b1), s2 = 1:ncol(b2)), Batch = list(s1 = rep(&#39;Batch1&#39;,10), s2 = c(rep(&#39;Batch2&#39;,5),rep(&#39;Batch3&#39;,5)))) And to create a MultiBlock with sample metadata, the easiest way is with the function AddMetadata: b4 &lt;- AddMetadata(newBlock = matrix(rnorm(100),10,10), metadata = data.frame(x1 = c(rep(0,5),rep(1,5)), x2 = c(rep(1,3),rep(2,4),rep(3,3)))) In AddMetadata, newBlock can be a matrix, a data.frame, or a MultiBlock object. In the giving example, the metadata contains two variables (x1 and x2). 3.2 Option 2: for large MultiBlocks Then, it is possible to create a MultiBlock from another preexisting MultiBlock. In this case, the function BuildMultiBlock() comes in handy. MB &lt;- BuildMultiBlock(b1,b2,b3,ignore.names = TRUE) getBlockNames(MB) 3.3 Option 3: from SummarizedExperiment or MultiAssayExperiment objects. MultiBlocks can also be created from SummarizedExperiment or MultiAssayExperiment objects, which are pretty common format nowadays in multi-omics studies. In the same way, MultiBlocks can be converted back to MultiAssayExperiments. library(MultiAssayExperiment) data(miniACC) library(SummarizedExperiment) data(airway, package=&quot;airway&quot;) MB1 &lt;- SummarizedExperiment2MultiBlock(airway, colData_samplenames = &#39;Run&#39;, Batch = NULL) MB2 &lt;- MultiAssayExperiment2MultiBlock(miniACC, colData_samplenames = &#39;patientID&#39;, Batch = NULL) se2 &lt;- MultiBlock2MultiAssayExperiment(MB2, MSEmetadata = NULL) 3.4 Sample correspondence across blocks We define as sample correspondence across blocks to the fact that the sample order is maintained across blocks. That is, the first sample from the first block has a correspondence sample in the second block at the same position, and so on. To run ComDim and most multi-omics analysis in general, sample correspondence across blocks is needed. This is normally verified by the user. For R.ComDim, we can use BuildMultiBlock() to check for the same correspondence and resort samples (and discard) if needed. This process is achieved with the option ignore.names = FALSE (the default). c1 = matrix(1:500,10,50) # 10 rows and 50 columns c2 = matrix(500:1,10,50) # 10 rows and 50 columns c3 = matrix(501:1000,10,50) # 10 rows and 50 columns c4 = matrix(1:1000,20,50) # 20 rows and 50 columns rownames(c1) &lt;- paste0(&#39;c&#39;,6:15) rownames(c2) &lt;- paste0(&#39;c&#39;,1:10) rownames(c3) &lt;- paste0(&#39;c&#39;,10:1) rownames(c4) &lt;- paste0(&#39;c&#39;,1:20) # With ignore.names = FALSE, only common samples across blocks are kept. # Samples will be resorted if needed. MB12 &lt;- BuildMultiBlock(c1,c2,ignore.names = FALSE) # 10 samples in common MB13 &lt;- BuildMultiBlock(c1,c3,ignore.names = FALSE) # 5 samples in common MB13b &lt;- BuildMultiBlock(c1,c3,ignore.names = TRUE) # Blocks were appended # regardless of their sample # names. Sample names were # replaced by integers. # (Not run) The following code does not work because block sizes are different # and ignore.names = TRUE. #MB14 &lt;- BuildMultiBlock(c1,c4,ignore.names = TRUE) If we dont need to verify the sample correspondence across blocks, we can use ignore.names = TRUE. However, in case the sample size is different across blocks, the MultiBlock will not be built (as the sample correspondence does not actually exist). It is possible to overrid this situation with ignore.size = TRUE, but the resulting MultiBlock is not compatible for ComDim analyses. # Option A (ignore.names = FALSE) : Only common samples across blocks are kept. MB14c &lt;- BuildMultiBlock(c1,c4,ignore.names = FALSE) # Option B (ignore.names = TRUE, ignore.size = TRUE): # Blocks were appended regardless of their sample names and sizes. # All samples were kept. MB14b &lt;- BuildMultiBlock(c1,c4,ignore.names = TRUE, ignore.size = TRUE) # MB14b is not compatible with ComDim getSampleNames(MB14b) # A particularity of this MB14b is that it has one &#39;Samples&#39; vector per block. 3.5 Splitting blocks by the Batch criterion. We can consider split one or more blocks according to the Batch criterion, in order to examine whether this factor contains is a relevant source of information in our dataset. This is performed with the SplitRW() function. We call this split strategy Replicate-Wise (RW). # Build the MultiBlock x1 = MultiBlock(Samples = 1:10, Data = list(x1 = matrix(rnorm(500),10,50)), Variables = list(x1 = 1:50), Batch = list(x1 = rep(&#39;Batch1&#39;,10))) x2 = MultiBlock(Samples = c(1:10,1:10,1:10), Data = list(x2 = matrix(rnorm(2400),30,80)), Variables = list(x2 = 1:80), Batch = list(x2 = c(rep(&#39;Batch1&#39;,10), rep(&#39;Batch2&#39;,10), rep(&#39;Batch3&#39;,10))) ) x1x2 &lt;- BuildMultiBlock(x1,x2, ignore.names = TRUE, ignore.size = TRUE) # Proceed with the split. rw &lt;- SplitRW(x1x2) # SplitRW looks specifically to the Batch information. More information about the reasoning behind this analytical strategy can be consulted here: [https://doi.org/10.1016/j.chemolab.2021.104422] (https://doi.org/10.1016/j.chemolab.2021.104422). In case there exist sample correspondence although the sample names do not match across blocks, we can force the MultiBlock split with the argument checkSampleCorrespondence = FALSE. # Build the MultiBlock x4 = MultiBlock(Samples = c(1:30), Data = list(x4 = matrix(rnorm(2400),30,80)), Variables = list(x4 = 1:80), Batch = list(x4 = c(rep(&#39;Batch1&#39;,10), rep(&#39;Batch2&#39;,10), rep(&#39;Batch3&#39;,10))) ) x1x4 &lt;- BuildMultiBlock(x1,x4, ignore.names = TRUE, ignore.size = TRUE) # Sample names in block x1 go from 1 to 10. # Sample names in block x4 go from 1 to 10 (batch1), 11 to 20 (batch2), # and 21 to 30 (batch3). Despite the sample names does not batch, samples # have correspondence across blocks. Thus, we need to impose **not to** # check the sample names. This is done with checkSampleCorrespondence = FALSE. # Proceed with the split. rw2 &lt;- SplitRW(x1x4, checkSampleCorrespondence = FALSE) With checkSampleCorrespondence = TRUE, only the common samples across blocks are kept. # Build the MultiBlock x5 = MultiBlock(Samples = c(1:10, 5:14, 1:10), Data = list(x5 = matrix(rnorm(2400),30,80)), Variables = list(x5 = 1:80), Batch = list(x5 = c(rep(&#39;Batch1&#39;,10), rep(&#39;Batch2&#39;,10), rep(&#39;Batch3&#39;,10))) ) x1x5 &lt;- BuildMultiBlock(x1,x5, ignore.size = TRUE, ignore.names = TRUE) # Proceed with the split. rw3 &lt;- SplitRW(x1x5, checkSampleCorrespondence = TRUE) "],["handling.html", "Chapter 4 MultiBlock data handling 4.1 Inspecting the data 4.2 Data pre-processing", " Chapter 4 MultiBlock data handling 4.1 Inspecting the data We can easily read the content of a MultiBlock object with the following functions: getSampleNames(MB) ## [1] 1 2 3 4 5 6 7 8 9 10 getVariableNames(MB) ## $b1 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## ## $b2 ## [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; &quot;V5&quot; &quot;V6&quot; &quot;V7&quot; &quot;V8&quot; &quot;V9&quot; &quot;V10&quot; &quot;V11&quot; &quot;V12&quot; ## [13] &quot;V13&quot; &quot;V14&quot; &quot;V15&quot; &quot;V16&quot; &quot;V17&quot; &quot;V18&quot; &quot;V19&quot; &quot;V20&quot; &quot;V21&quot; &quot;V22&quot; &quot;V23&quot; &quot;V24&quot; ## [25] &quot;V25&quot; &quot;V26&quot; &quot;V27&quot; &quot;V28&quot; &quot;V29&quot; &quot;V30&quot; &quot;V31&quot; &quot;V32&quot; &quot;V33&quot; &quot;V34&quot; &quot;V35&quot; &quot;V36&quot; ## [37] &quot;V37&quot; &quot;V38&quot; &quot;V39&quot; &quot;V40&quot; &quot;V41&quot; &quot;V42&quot; &quot;V43&quot; &quot;V44&quot; &quot;V45&quot; &quot;V46&quot; &quot;V47&quot; &quot;V48&quot; ## [49] &quot;V49&quot; &quot;V50&quot; &quot;V51&quot; &quot;V52&quot; &quot;V53&quot; &quot;V54&quot; &quot;V55&quot; &quot;V56&quot; &quot;V57&quot; &quot;V58&quot; &quot;V59&quot; &quot;V60&quot; ## [61] &quot;V61&quot; &quot;V62&quot; &quot;V63&quot; &quot;V64&quot; &quot;V65&quot; &quot;V66&quot; &quot;V67&quot; &quot;V68&quot; &quot;V69&quot; &quot;V70&quot; &quot;V71&quot; &quot;V72&quot; ## [73] &quot;V73&quot; &quot;V74&quot; &quot;V75&quot; &quot;V76&quot; &quot;V77&quot; &quot;V78&quot; &quot;V79&quot; &quot;V80&quot; ## ## $s1 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## ## $s2 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 ## [76] 76 77 78 79 80 getVariableNames(MB, block = 2) ## [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; &quot;V5&quot; &quot;V6&quot; &quot;V7&quot; &quot;V8&quot; &quot;V9&quot; &quot;V10&quot; &quot;V11&quot; &quot;V12&quot; ## [13] &quot;V13&quot; &quot;V14&quot; &quot;V15&quot; &quot;V16&quot; &quot;V17&quot; &quot;V18&quot; &quot;V19&quot; &quot;V20&quot; &quot;V21&quot; &quot;V22&quot; &quot;V23&quot; &quot;V24&quot; ## [25] &quot;V25&quot; &quot;V26&quot; &quot;V27&quot; &quot;V28&quot; &quot;V29&quot; &quot;V30&quot; &quot;V31&quot; &quot;V32&quot; &quot;V33&quot; &quot;V34&quot; &quot;V35&quot; &quot;V36&quot; ## [37] &quot;V37&quot; &quot;V38&quot; &quot;V39&quot; &quot;V40&quot; &quot;V41&quot; &quot;V42&quot; &quot;V43&quot; &quot;V44&quot; &quot;V45&quot; &quot;V46&quot; &quot;V47&quot; &quot;V48&quot; ## [49] &quot;V49&quot; &quot;V50&quot; &quot;V51&quot; &quot;V52&quot; &quot;V53&quot; &quot;V54&quot; &quot;V55&quot; &quot;V56&quot; &quot;V57&quot; &quot;V58&quot; &quot;V59&quot; &quot;V60&quot; ## [61] &quot;V61&quot; &quot;V62&quot; &quot;V63&quot; &quot;V64&quot; &quot;V65&quot; &quot;V66&quot; &quot;V67&quot; &quot;V68&quot; &quot;V69&quot; &quot;V70&quot; &quot;V71&quot; &quot;V72&quot; ## [73] &quot;V73&quot; &quot;V74&quot; &quot;V75&quot; &quot;V76&quot; &quot;V77&quot; &quot;V78&quot; &quot;V79&quot; &quot;V80&quot; getBlockNames(MB) ## [1] &quot;b1&quot; &quot;b2&quot; &quot;s1&quot; &quot;s2&quot; getBlockNames(MB, &quot;Batch&quot;) ## NULL getBlockNames(MB, &quot;Metadata&quot;) ## NULL ncolMultiBlock(MB) ## [1] 50 80 50 80 nrowMultiBlock(MB) ## [1] 10 10 10 10 MB2&lt;- FilterSamplesMultiBlock(MB, c(1:9)) # To create a MultiBlock with # a sample subset. In this case, we selected samples 1-9. Or we can simply see all the content with str() function. If needed, everything in the MB can be renamed. MB &lt;- setBlockNames(MB, paste(&quot;X&quot;, 1:4, sep = &#39;&#39;)) # The blocks getBlockNames(MB) MB &lt;- setSampleNames(MB, LETTERS[1:10]) # The samples getSampleNames(MB) MB &lt;- setVariableNames(MB, paste(&quot;vars&quot;, 1:50, sep = &#39;&#39;), 1) getVariableNames(MB, 1) 4.2 Data pre-processing The R.ComDim package contains functions to easily apply some data transformations. This can result in handy since we there is no need to build the MultiBlock every time a new data transformation is tested. ## NA removal # We first add some NAs to the MultiBlock. MB@Data$X2[c(2,3,5),c(1,2,3)] &lt;- NA # Add some NAs allMB &lt;- NARemoveMultiBlock(MB, method = &#39;none&#39;, minfrac = 0.2) # Variables containing more than 20% of NAs will be discarded ## Data normalization allMB &lt;- NormalizeMultiBlock(allMB, method = &#39;norm&#39;) # MB is normalized (mean-center and divided by the block norm) The R.ComDim package has been writted with the idea to result very flexible and, as such, it allows the user to apply custom data transformations. For instance, in the code below, all variables with values lower than the 5% of the most intense value are discarded. # MB is converted to matrix to calculate the max value. maxMB &lt;- max(MultiBlock2matrix(allMB), na.rm = TRUE) # Variables are filtered with the ProcessMultiBlock() function. allMB &lt;- ProcessMultiBlock(allMB, FUN.SelectVars = function(x) {apply(x,2,max) &gt; maxMB * 0.05}) "],["multi-omics.html", "Chapter 5 Multi-omics amd Multi-blocks 5.1 Data processing 5.2 Data analysis 5.3 Data prediction", " Chapter 5 Multi-omics amd Multi-blocks This section will be explained with a multi-omics dataset from an exposition experiment on normal and tumoral cells. The dataset contains 4 different types of data (RNAseq, lipidomics, intracellular and extracellular metabolites). The studied samples can be classified into 3 groups: NI - non-induced (normal cells) DOX - doxycycline induced (tumoral cells), OFF - residual cells (treatment-resistant tumoral cells) More information regarding the experimental protocol can be consulted here. The metabolomics data was downloaded from Metabolights MTBLS1507 while the RNAseq data was obtained from ARRAYEXPRESS E-MTAB-8834. data(mouse_ds) allMB &lt;- BuildMultiBlock(t(RNAseq3[,1:12]), t(lipids), t(intra), t(extra)) allMB &lt;- setBlockNames(allMB, c(&#39;RNAseq&#39;, &#39;lipids&#39;,&#39;intra&#39;,&#39;extra&#39;)) 5.1 Data processing This is an example of a possible data processing: # 1) Exclude normalized variables with max intensity reported below 0.1% of the # max from all RNAseq blocks. allMB &lt;- ProcessMultiBlock( allMB, blocks = &#39;RNAseq&#39;, FUN.SelectVars = function(x) {apply(x,2,max) &gt; max(x, na.rm = TRUE) * 0.001}) allMB &lt;- NARemoveMultiBlock(allMB, blocks = &#39;RNAseq&#39;, method = &#39;fixed.value.all&#39;, constant = 1) # 2) Do rlog transform of the RNAseq data (rlog assumes samples in columns) # The rlog transform function is obtained from the DESeq2 R-package. library(DESeq2) allMB &lt;- ProcessMultiBlock(allMB, blocks = &#39;RNAseq&#39;, FUN = function(x){t(DESeq2::rlog(t(x)))}) # 3) Replace NAs by random noise allMB &lt;- NARemoveMultiBlock(allMB, method = &#39;random.noise&#39;) # 4) Normalize (mean-center and divided by each block-norm) allMB &lt;- NormalizeMultiBlock(allMB, method = &#39;norm&#39;) 5.2 Data analysis We use in this example ComDim-PCA, which is intended for exploratory purposes. The ComDim analysis is run with 2 components. resultsPCA &lt;- ComDim_PCA_MB(allMB, ndim = 2) # 2 Components. resultsPCA is an object of class ComDim. Lets proceed now to inspect some of the results from this analysis. 5.2.1 Saliences We can start by looking at the saliences, which show the contribution of each block for every component. saliences &lt;- resultsPCA@Saliences %&gt;% as.data.frame() %&gt;% mutate(dataset = rownames(.)) %&gt;% pivot_longer(cols = c(&#39;CC1&#39;,&#39;CC2&#39;), names_to = &#39;CC&#39;, values_to = &#39;Salience&#39;) saliences # The salience values. ggplot(data = saliences, aes(x = CC, y = Salience, group = dataset )) + geom_bar(stat = &#39;identity&#39;, position = &#39;dodge&#39;, aes(fill = dataset)) + theme_minimal() + labs(title = &#39;ComDim Saliences&#39;) 5.2.2 Scores The scores give the contribution of each sample. There are two types of scores, Global (Q.scores) and Local (T.scores). Global scores show the contribution for the total model (all blocks) while the Local scores give the contribution for each of the blocks. scoresTable &lt;- MakeComDimScoresTable(model = resultsPCA) head(scoresTable) # The 6 first rows of the scores table scoresTable_wider &lt;- scoresTable %&gt;% mutate(sample.type = case_when(grepl(&#39;DOX&#39;, sample.id) ~ &#39;DOX&#39;, grepl(&#39;NI&#39;, sample.id) ~ &#39;NI&#39;, grepl(&#39;OFF&#39;, sample.id) ~ &#39;OFF&#39;)) %&gt;% dplyr::select(sample.id, sample.type, block.name, scores.type.dim, value) %&gt;% dplyr::group_by(sample.id, sample.type, scores.type.dim, block.name) %&gt;% pivot_wider(names_from = scores.type.dim, values_from = value) ggplot(data = scoresTable_wider) + geom_point(aes(x = T.scores1, y = T.scores2, color = sample.type, shape = block.name)) + geom_point(aes(x = Q.scores1, y = Q.scores2, fill = sample.type, shape = block.name), size = 3, shape = 24, color = &#39;black&#39;) + theme_minimal() + labs(title = &#39;ComDim scores&#39;, x = &#39;CC1&#39;, y = &#39;CC2&#39;) # OFF samples are very different than DOX and NI by their lipid content. # Extracellular metabolites are not very different 5.2.3 Loadings The loadings give the contribution of each variable in the model. And example of how to use the loadings is presented in the next section. 5.3 Data prediction The built model can be used to investigate new samples if available. pred.resultsPCA &lt;- Predict_MB(MB = allMB, model = resultsPCA) data.frame(original = resultsPCA@T.scores[[2]][,1], predicted = pred.resultsPCA@T.scores[[2]][,1]) data.frame(original = resultsPCA@Q.scores[,2], predicted = resultsPCA@Q.scores[,2]) In this example, the original and predicted scores are identical because the new samples are the same as the original ones. "],["Section5.html", "Chapter 6 Data from a single omics data are multi-blocks 6.1 Molecular functions", " Chapter 6 Data from a single omics data are multi-blocks Metabolic pathways are composed by a group of related metabolites. Extrapolating this concept into the MultiBlock domain, it is possible to convert a metabolomics dataset into a MultiBlock, where each of the blocks will be characteristic of one metabolic pathway. This strategy can be applied to other types of omics datasets. For example, transcriptomics datasets can be transformed to MultiBlocks by the Gene Ontology information, and phylogenetic data can be split according to any of the taxonomic levels (class, family, gender, species,). In the R.ComDim package, this data transformation can be mediated with the ExpandMultiBlock() function and a reference metadata file with the list of categories each variable can be listed in. In the resulting MultiBlock, a variable will be included in as many blocks as groups (i.e. molecular function) it belongs to. data(mouse_ds) lipidsMB &lt;- ExpandMultiBlock(data = lipids, metadata = metadata_lipids, minblock = 0, loquace = FALSE) extraMB &lt;- ExpandMultiBlock(data = extra, metadata = KEGG_table_metabolites, minblock = 10, loquace = FALSE) intraMB &lt;- ExpandMultiBlock(data = intra, metadata = KEGG_table_metabolites, minblock = 10, loquace = FALSE) RNAseqMB &lt;- ExpandMultiBlock(data = RNAseq3[,1:12], metadata = metadata_RNAseq3, minblock = 500, loquace = FALSE) # We can count the number of blocks in each MultiBlock length(getBlockNames(lipidsMB)) # 4 blocks length(getBlockNames(extraMB)) # 12 blocks length(getBlockNames(intraMB)) # 12 blocks length(getBlockNames(RNAseqMB)) # 16 blocks Since the blocks from this MultiBlock are related to a specific biological role, the ComDim analysis can be used to determine the biological roles more important in the the studied dataset. In the MultiBlocks above, we only kept those blocks containing equal or more than minblock variables (i.e. only the RNAseq-related blocks containing 500 or more variables were kept). In order to find the most relevant pathways, ComDim will consider all blocks equally important, causing that the variables from the smallest blocks will contribute more to the final model than the variables from the largest blocks. Then, the minblock filter is applied to avoid that the smallest blocks (which usually relate to poorly-characterized biological roles, and thus hardly interpretable) influence the ComDim model construction. Lets continue with the example from before, but before the ComDim analysis we can apply some data transformations. # Blocks are relabelled for clarity lipidsMB &lt;- setBlockNames(lipidsMB, paste(&quot;lipids&quot;, getBlockNames(lipidsMB), sep = &#39;.&#39;)) intraMB &lt;- setBlockNames(intraMB, paste(&quot;intra&quot;, getBlockNames(intraMB), sep = &#39;.&#39;)) extraMB &lt;- setBlockNames(extraMB, paste(&quot;extra&quot;, getBlockNames(extraMB), sep = &#39;.&#39;)) RNAseqMB &lt;- setBlockNames(RNAseqMB, paste(&quot;RNAseq&quot;, getBlockNames(RNAseqMB), sep = &#39;.&#39;)) allMB2 &lt;- BuildMultiBlock(RNAseqMB, lipidsMB, intraMB, extraMB) Now, all 4 MultiBlocks were merged into a single MultiBlock, and each block contains a suffix denoting the omics data type. We apply some data pre-processings: # We apply some pre-processings library(DESeq2) # Remove blocks relative to map01100 # (not very informative, it&#39;s the map with all metabolic pathways) allMB2 &lt;- ProcessMultiBlock(allMB2, blocks = which(grepl(&#39;map01100&#39;, getBlockNames(allMB2))), # All blocks with map01100 are deleted, since ncol(x) is always &gt; 0. FUN.SelectBlocks = function(x){ncol(x) &lt; 0}) # Calculate the absolute maximum from the RNAseq data. maxMB &lt;- max(MultiBlock2matrix(allMB2, blocks = grep(&#39;RNAseq&#39;,getBlockNames(allMB2)) ), na.rm = TRUE) # Exclude normalized variables with max intensity reported below 0.1% # of the max from all RNAseq blocks. allMB2 &lt;- ProcessMultiBlock(allMB2, blocks = grep(&#39;RNAseq&#39;,getBlockNames(allMB2)), FUN.SelectVars = function(x) {apply(x,2,max) &gt; maxMB * 0.001}) # Add 1 to each value in RNAseq data to remove 0s. allMB2 &lt;- NARemoveMultiBlock(allMB2, blocks = grep(&#39;RNAseq&#39;,getBlockNames(allMB2)), method = &#39;fixed.value.all&#39;, constant = 1) # Do rlog transform of the RNAseq data. allMB2 &lt;- ProcessMultiBlock(allMB2, blocks = grep(&#39;RNAseq&#39;,getBlockNames(allMB2)), # Normalize rlog transcript counts FUN = function(x){t(DESeq2::rlog(t(x)))}) # Replace NAs by random noise allMB2 &lt;- NARemoveMultiBlock(allMB2, method = &#39;random.noise&#39;) # Normalize (mean-center and divided by each block-norm) allMB2 &lt;- NormalizeMultiBlock(allMB2, method = &#39;norm&#39;) We continue with the ComDim analysis: resultsPCA2 &lt;- ComDim_PCA_MB(allMB2, ndim = 2) A first look at the scores can tell us how the blocks relate to the sample type. scoresTable &lt;- MakeComDimScoresTable(model = resultsPCA2) scoresTable_wider &lt;- scoresTable %&gt;% mutate(sample.type = case_when(grepl(&#39;DOX&#39;, sample.id) ~ &#39;DOX&#39;, grepl(&#39;NI&#39;, sample.id) ~ &#39;NI&#39;, grepl(&#39;OFF&#39;, sample.id) ~ &#39;OFF&#39;)) %&gt;% dplyr::select(sample.id, sample.type, block.name, scores.type.dim, value) %&gt;% dplyr::group_by(sample.id, sample.type, scores.type.dim, block.name) %&gt;% pivot_wider(names_from = scores.type.dim, values_from = value) %&gt;% mutate(omics = case_when(grepl(&#39;RNAseq&#39;, block.name) ~ &#39;RNAseq&#39;, grepl(&#39;lipids&#39;, block.name) ~ &#39;lipids&#39;, grepl(&#39;extra&#39;, block.name) ~ &#39;extra&#39;, grepl(&#39;intra&#39;, block.name) ~ &#39;intra&#39;, grepl(&#39;Global&#39;, block.name) ~ &#39;Global&#39;)) ggplot(data = scoresTable_wider) + geom_point(aes(x = T.scores1, y = T.scores2, color = sample.type, shape = omics)) + geom_point(aes(x = Q.scores1, y = Q.scores2, fill = sample.type), size = 3, shape = 24, color = &#39;black&#39;) + theme_minimal() + labs(title = &#39;ComDim scores&#39;, x = &#39;CC1&#39;, y = &#39;CC2&#39;) The metabolomic and the RNAseq profiles appear to be very orthogonal (uncorrelated), since intra and extra does not change much (within each group) in CC2 whereas the RNAseq does not change much in CC1. For RNAseq molecular functions, CC1 separates OFF from NI and DOX. CC2 separates DOX from NI and OFF. Despite this, NI seems to be different from DOX and OFF at the lipidomic level. 6.1 Molecular functions Lets start by looking at the saliences: # Plot saliences saliences2 &lt;- resultsPCA2@Saliences %&gt;% as.data.frame() %&gt;% mutate(dataset = rownames(.)) %&gt;% pivot_longer(cols = c(&#39;CC1&#39;,&#39;CC2&#39;), names_to = &#39;CC&#39;, values_to = &#39;Salience&#39;) %&gt;% mutate(omics = case_when(grepl(&#39;RNAseq&#39;, dataset) ~ &#39;RNAseq&#39;, grepl(&#39;lipids&#39;, dataset) ~ &#39;lipids&#39;, grepl(&#39;extra&#39;, dataset) ~ &#39;extra&#39;, grepl(&#39;intra&#39;, dataset) ~ &#39;intra&#39;)) ggplot(data = saliences2, aes(x = CC, y = Salience, group = dataset )) + geom_bar(stat = &#39;identity&#39;, position = &#39;dodge&#39;, aes(fill = omics)) + theme_minimal() + geom_text(label = &#39;lipids.GLP&#39;, x = 2, y = 0.4, size = 3) + geom_text(label = &#39;intra.map04978&#39;, x = 1.25, y = 0.88, size = 3) + labs(title = &#39;ComDim Saliences&#39;) CC1 is descriptive of metabolomics data (both intra and extra) CC2 is descriptive of RNAseq and glycerophospholipids (lipids.GLP) The most altered molecular function is map04978 (mineral absorption), in the intra data. 6.1.1 The molecular patwhays By inspecting the loadings, we can have an idea of the most altered omics features in the block. We will plot now the loadings for the two most relevant blocks as seen in the previous section. # MINERAL ABSORPTION LoadingsTable &lt;- MakeComDimLoadingsTable(model = resultsPCA2, block = &#39;intra.map04978&#39;, dim = 1) ggplot(LoadingsTable, aes(x = variable.id, y = value)) + geom_bar(stat = &#39;identity&#39;) + labs(title = &#39;MINERAL ABSORPTION&#39;) + theme_minimal() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) # GLYCEROPHOSPHOLIPIDS LoadingsTable &lt;- MakeComDimLoadingsTable(model = resultsPCA2, block = &#39;lipids.GPL&#39;, dim = 2) ggplot(LoadingsTable, aes(x = variable.id, y = value)) + geom_bar(stat = &#39;identity&#39;) + labs(title = &#39;GLYCEROPHOSPHOLIPIDS&#39;) + theme_minimal() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 3)) Most important changes in the GPL group occur for PC36:2, PC34:1, PC:34:2, PE36:2, PC36:1, We can also plot the loadings into KEGG pathway maps (if the omics variables can be matched with the KEGG identifiers). Here is an example for the metabolomics data: # MINERAL ABSORPTION # Prepare input data loadingVector &lt;- LoadingsTable$value * 10 # 10 is a factor used to maximize # the color contrast in the resulting # KEGG map. names(loadingVector) &lt;- gsub(&quot;map04978.&quot;,&quot;&quot;,LoadingsTable$variable.id) library(pathview) # From Bioconductor pv.out &lt;- pathview(cpd.data = loadingVector, pathway.id = &quot;04978&quot;, species = &quot;mmu&quot;, out.suffix = &quot;ComDim&quot;) The map is saved in the working directory: And here, there is an example for the RNAseq-data (block mmu05200, Pathways in Cancer): LoadingsTable &lt;- MakeComDimLoadingsTable(model = resultsPCA2, block = &#39;RNAseq.mmu05200&#39;, dim = 2) # Prepare input data loadingVector &lt;- LoadingsTable$value * 10 # 10 is a factor to maximize # the color contrast in the # resulting KEGG map. names(loadingVector) &lt;- gsub(&quot;mmu05200.&quot;,&quot;&quot;,LoadingsTable$variable.id) library(pathview) # From Bioconductor pv.out &lt;- pathview(gene.data = loadingVector, pathway.id = &quot;05200&quot;, species = &quot;mmu&quot;, out.suffix = &quot;ComDim&quot;) "],["Section6.html", "Chapter 7 Data from a single omics data are multi-blocks 7.1 ComDim-Partial Least Squares (ComDim-PLS) 7.2 ComDim-Partial Least Squares Discriminant Analysis (ComDim-PLSDA) 7.3 ComDim-kernel-OPLS 7.4 Other extensions", " Chapter 7 Data from a single omics data are multi-blocks In the previous sections, we have only used ComDim-PCA, but many other ComDim versions exist. ComDim can be regarded as a chemometric method able to compact the relevant information of the data into a reduced subspace, defined by the scores, the loadings and the saliences. Although most ComDim analyses employ Principal Component Analysis (PCA) as the core method to find this reduced space, other approaches can be used. The R.Comdim package includes a few of those other methods, as well as some additional functions to allow the users to create their own ComDim methods. 7.1 ComDim-Partial Least Squares (ComDim-PLS) resultsPLSR &lt;- ComDim_PLS_MB(allMB, y= c(rep(1,4),rep(5,4),rep(10,4)), # Arbitrary scale, just for the demonstration ndim = 2, method = &#39;PLS-R&#39;) 7.2 ComDim-Partial Least Squares Discriminant Analysis (ComDim-PLSDA) resultsPLSDA &lt;- ComDim_PLS_MB(allMB, y= c(rep(&#39;NI&#39;,4),rep(&#39;DOX&#39;,4),rep(&#39;OFF&#39;,4)), ndim = 2, method = &#39;PLS-DA&#39;) # Method evaluation resultsPLSDA@R2X resultsPLSDA@R2Y resultsPLSDA@Q2 resultsPLSDA@Prediction$confusionMatrix # Plot saliences saliencesPLSDA &lt;- resultsPLSDA@Saliences %&gt;% as.data.frame() %&gt;% mutate(dataset = rownames(.)) %&gt;% pivot_longer(cols = c(&#39;CC1&#39;,&#39;CC2&#39;), names_to = &#39;CC&#39;, values_to = &#39;Salience&#39;) ggplot(data = saliencesPLSDA, aes(x = CC, y = Salience, group = dataset )) + geom_bar(stat = &#39;identity&#39;, position = &#39;dodge&#39;, aes(fill = dataset)) + theme_minimal() + labs(title = &#39;ComDim Saliences&#39;) # Plot scores scoresTable &lt;- MakeComDimScoresTable(model = resultsPLSDA) scoresTable_wider &lt;- scoresTable %&gt;% mutate(sample.type = case_when(grepl(&#39;DOX&#39;, sample.id) ~ &#39;DOX&#39;, grepl(&#39;NI&#39;, sample.id) ~ &#39;NI&#39;, grepl(&#39;OFF&#39;, sample.id) ~ &#39;OFF&#39;)) %&gt;% dplyr::select(sample.id, sample.type, block.name, scores.type.dim, value) %&gt;% dplyr::group_by(sample.id, sample.type, scores.type.dim, block.name) %&gt;% pivot_wider(names_from = scores.type.dim, values_from = value) ggplot(data = scoresTable_wider) + geom_point(aes(x = T.scores1, y = T.scores2, color = sample.type, shape = block.name)) + geom_point(aes(x = Q.scores1, y = Q.scores2, fill = sample.type, shape = block.name), size = 3, shape = 24, color = &#39;black&#39;) + theme_minimal() + labs(title = &#39;ComDim scores - PLSDA&#39;, x = &#39;CC1&#39;, y = &#39;CC2&#39;) 7.3 ComDim-kernel-OPLS source(&#39;./R/ComDim_KOPLS_MB.R&#39;) resultsKOPLSDA &lt;- ComDim_KOPLS_MB(allMB, y= c(rep(&#39;NI&#39;,4),rep(&#39;DOX&#39;,4),rep(&#39;OFF&#39;,4)), max.ort = 2, method = &#39;k-OPLS-DA&#39;, nrcv = 5) 7.4 Other extensions The functions ComDim_Exploratory_MB() and ComDim_y_MB() can be employed to use customized versions of Com-Dim for exploratory and regression/discriminant purposes. In both functions, the parameter FUN allows the user to run ComDim with their chemometric method of preference. 7.4.1 Example of ComDim-ICA The function used to execute Independent Component Analysis (ICA) was ica() from the ica package. In order to make the ComDim_Exploratory_MB() function to understand the output of ica(), we embedded it into another function that returns the source estimates (representative of the samples information, analogous to the PCA scores) named fun.ICA. library(ica) fun.ICA &lt;- function(W, ndim,...){ # W is the concatenated MB. # ndim is the number of components. # X and nc are the arguments of ica::ica. result &lt;- ica::ica(W, ndim) sources &lt;- result$S # The function must return the source estimates # The analogue to the PCA scores for ICA. return(sources) } resultsICA &lt;- ComDim_Exploratory_MB(allMB, ndim = 2, FUN = fun.ICA, method = &#39;ICA&#39;) 7.4.2 Example of ComDim-PLS (version ropls) The function used to execute PLS here was opls(), obtained from the ropls package. In this case, fun.PLS is used to capture the output from the PLS analysis (scores,P,W,U,Q,y). library(ropls) # From bioconductor source(&#39;./R/ComDim_y_MB.R&#39;) fun.PLS &lt;- function(W, y, ndim,...){ # W is the concatenated MB. # ndim is the number of components. # X and nc are the arguments of ica::ica. output &lt;- list() result &lt;- ropls::opls(x = W, y = y, predI = ndim, fig.pdfC = &#39;none&#39;, info.txtC = &#39;none&#39;) # The returning object must be a list containing the following 6 elements: output$scores &lt;- result@scoreMN[,1] output$P &lt;- result@loadingMN[,1] output$W &lt;- result@weightMN[,1] output$U &lt;- result@uMN[,1] output$Q &lt;- result@cMN[,1] output$y &lt;- result@suppLs$yModelMN # To evaluate if y is transformed within opls. (it is!) return(output) } resultsPLS &lt;- ComDim_y_MB(allMB, y =c(rep(1,4),rep(5,4),rep(10,4)), ndim = 2, type = &#39;regression&#39;, orthogonalization = FALSE, FUN = fun.PLS, method = &#39;PLS(ropls)&#39;) 7.4.3 Example of ComDim-PLSDA (version ropls) For ComDim-PLS-DA, we can use the same function fun.PLS as before, but we need to specify that the type of the method is 'discriminant' and we need to provide the sample classes in y: resultsPLSDA &lt;- ComDim_y_MB(allMB, y =c(rep(&#39;NI&#39;,4),rep(&#39;DOX&#39;,4),rep(&#39;OFF&#39;,4)), ndim = 2, type = &#39;discriminant&#39;, orthogonalization = FALSE, FUN = fun.PLS, method = &#39;PLSDA(ropls)&#39;) 7.4.4 Example of ComDim-OPLSDA (version ropls) For ComDim-OPLSDA, the function in FUN needs to capture additional outputs related to the orthogonal components. See the example below: # We will apply ComDim-OPLSDA on a subset with 2 classes only. allMB_small &lt;- FilterSamples_MB(allMB, getSampleNames(allMB)[c(1:4,9:12)]) fun.OPLSDA &lt;- function(W, y, ndim,...){ # W is the concatenated MB. # ndim is the number of components. output &lt;- list() Y &lt;- c(-1,1)[apply(y, 1, function(x) match(1,x))] # Y must be a vector for ropls result &lt;- ropls::opls(x = W, y = Y, predI = 1, orthoI = NA, # The number of orthogonal components # is optimized for every block. fig.pdfC = &#39;none&#39;, info.txtC = &#39;none&#39;) # The returning object must be a list containing the following 9 elements: output$scores &lt;- result@scoreMN[,1] output$P &lt;- result@loadingMN[,1] output$W &lt;- result@weightMN[,1] output$U &lt;- result@uMN[,1] output$Q &lt;- result@cMN[,1] output$Q &lt;- c(-output$Q,output$Q) # Y has two columns (one per class): -1 and 1. output$y &lt;- result@suppLs$yModelMN # To evaluate if y is transformed within opls. (it is!) output$orthoscores &lt;- result@orthoScoreMN output$orthoP &lt;- result@orthoLoadingMN output$ort &lt;- result@summaryDF$ort # Number of orthogonal components return(output) } resultsOPLSDA &lt;- ComDim_y_MB(allMB_small, y =c(rep(&#39;NI&#39;,4),rep(&#39;OFF&#39;,4)), ndim = 1, type = &#39;discriminant&#39;, orthogonalization = TRUE, FUN = fun.OPLSDA, method = &#39;OPLSDA(ropls)&#39;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
